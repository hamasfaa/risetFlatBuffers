// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MONSTER_MYGAME_H_
#define FLATBUFFERS_GENERATED_MONSTER_MYGAME_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
                  FLATBUFFERS_VERSION_MINOR == 3 &&
                  FLATBUFFERS_VERSION_REVISION == 25,
              "Non-compatible flatbuffers version included");

namespace myGame
{

  struct Monster;
  struct MonsterBuilder;

  struct Monster FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
  {
    typedef MonsterBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
      VT_ID = 4,
      VT_NAME = 6,
      VT_HP = 8
    };
    int32_t id() const
    {
      return GetField<int32_t>(VT_ID, 0);
    }
    const ::flatbuffers::String *name() const
    {
      return GetPointer<const ::flatbuffers::String *>(VT_NAME);
    }
    int32_t hp() const
    {
      return GetField<int32_t>(VT_HP, 0);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
      return VerifyTableStart(verifier) &&
             VerifyField<int32_t>(verifier, VT_ID, 4) &&
             VerifyOffset(verifier, VT_NAME) &&
             verifier.VerifyString(name()) &&
             VerifyField<int32_t>(verifier, VT_HP, 4) &&
             verifier.EndTable();
    }
  };

  struct MonsterBuilder
  {
    typedef Monster Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_id(int32_t id)
    {
      fbb_.AddElement<int32_t>(Monster::VT_ID, id, 0);
    }
    void add_name(::flatbuffers::Offset<::flatbuffers::String> name)
    {
      fbb_.AddOffset(Monster::VT_NAME, name);
    }
    void add_hp(int32_t hp)
    {
      fbb_.AddElement<int32_t>(Monster::VT_HP, hp, 0);
    }
    explicit MonsterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
      start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Monster> Finish()
    {
      const auto end = fbb_.EndTable(start_);
      auto o = ::flatbuffers::Offset<Monster>(end);
      return o;
    }
  };

  inline ::flatbuffers::Offset<Monster> CreateMonster(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      int32_t id = 0,
      ::flatbuffers::Offset<::flatbuffers::String> name = 0,
      int32_t hp = 0)
  {
    MonsterBuilder builder_(_fbb);
    builder_.add_hp(hp);
    builder_.add_name(name);
    builder_.add_id(id);
    return builder_.Finish();
  }

  inline ::flatbuffers::Offset<Monster> CreateMonsterDirect(
      ::flatbuffers::FlatBufferBuilder &_fbb,
      int32_t id = 0,
      const char *name = nullptr,
      int32_t hp = 0)
  {
    auto name__ = name ? _fbb.CreateString(name) : 0;
    return myGame::CreateMonster(
        _fbb,
        id,
        name__,
        hp);
  }

} // namespace myGame

#endif // FLATBUFFERS_GENERATED_MONSTER_MYGAME_H_
